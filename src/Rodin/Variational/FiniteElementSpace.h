/*
 *          Copyright Carlos BRITO PACHECO 2021 - 2022.
 * Distributed under the Boost Software License, Version 1.0.
 *       (See accompanying file LICENSE or copy at
 *          https://www.boost.org/LICENSE_1_0.txt)
 */
#ifndef RODIN_VARIATIONAL_FINITEELEMENTSPACE_H
#define RODIN_VARIATIONAL_FINITEELEMENTSPACE_H

#include <variant>

#include "Rodin/Types.h"
#include "Rodin/Utility.h"
#include "Rodin/Geometry/Mesh.h"

#include "ForwardDecls.h"
#include "FiniteElement.h"

namespace Rodin::Variational
{
  /**
   * @brief Base class for finite element spaces.
   */
  class FiniteElementSpaceBase
  {
    public:
      FiniteElementSpaceBase() = default;

      FiniteElementSpaceBase(const FiniteElementSpaceBase&) = default;

      FiniteElementSpaceBase(FiniteElementSpaceBase&&) = default;

      FiniteElementSpaceBase& operator=(FiniteElementSpaceBase&&) = default;

      inline
      constexpr
      bool operator==(const FiniteElementSpaceBase& other) const
      {
        return this == &other;
      }

      inline
      constexpr
      bool operator!=(const FiniteElementSpaceBase& other) const
      {
        return this != &other;
      }

      /**
       * @brief Gets the total number of degrees of freedom.
       * @returns Size of the finite element space
       */
      virtual size_t getSize() const = 0;

      /**
       * @brief Gets the dimension of the range space, i.e. the number of
       * components of each basis function.
       * @returns Vector dimension of the finite element space.
       */
      virtual size_t getVectorDimension() const = 0;

      /**
       * @brief Gets the constant reference to the mesh upon which the finite
       * element space is built on.
       * @returns Constant reference to mesh
       */
      virtual const Geometry::MeshBase& getMesh() const = 0;

      /**
       * @brief Gets a set of global degree of freedom indices associated to
       * the polytope of dimension @f$ d @f$ and index @f$ i @f$.
       * @returns Set of indices associated to the @f$ (d, i) @f$-polytope.
       */
      virtual const IndexArray& getDOFs(size_t d, Index i) const = 0;

      /**
       * @brief Gets the global index for the local degree of freedom on the
       * polytope.
       */
      virtual Index getGlobalIndex(const std::pair<size_t, Index>& idx, Index local) const
      {
        const auto [d, i] = idx;
        return getDOFs(d, i).coeff(local);
      }
  };

  /**
   * @brief Represernts a finite element space.
   */
  template <class Derived>
  class FiniteElementSpace : public FiniteElementSpaceBase
  {
    public:
      /// Parent class
      using Parent = FiniteElementSpaceBase;

      /**
       * @brief Returns the mapping of the function from the physical element
       * to the reference element.
       * @tparam T Callable type
       * @param[in] p Index of the element in the mesh
       * @param[in] v Function defined on an element of the mesh
       *
       * For all @f$ \tau \in \mathcal{T}_h @f$ in the mesh, the finite
       * element space is generated by the bijective mapping:
       * @f[
       *  \psi_\tau : V(\tau) \rightarrow V(R)
       * @f]
       * taking a function @f$ v \in V(\tau) @f$ from the global element @f$
       * \tau @f$ to the reference element @f$ R @f$. Here the notation @f$
       * V(S) @f$ represents a Banach space of functions on the set @f$ S @f$.
       *
       * The callable type T must be a function on the mesh, i.e. the call
       * operator must have the following signature:
       *
       * @code{cpp}
       *  auto operator()(const Geometry::Point&);
       * @endcode
       *
       * @note CRTP function to be overriden in Derived class.
       */
      template <class T>
      auto getMapping(const std::pair<size_t, Index>& p, const T& v) const
      {
        return static_cast<const Derived&>(*this).getMapping(p, v);
      }
  };

  /**
   * @brief Base class for mappings taking functions defined on mesh elements
   * to reference elements.
   *
   * For all @f$ \tau \in \mathcal{T}_h @f$ the mapping
   * @f[
   *  \psi : V(\tau) \rightarrow V(K)
   * @f]
   * takes functions defined on the physical Banach space @f$ V(\tau) @f$ to
   * the reference Banach space @f$ V(K) @f$. Here @f$ \tau = x(K) @f$ is the
   * physical element, @f$ K @f$ is the reference element, and @f$ x : K
   * \rightarrow \tau @f$ is the
   * polytope transformation.
   *
   * @see FiniteElementSpaceInverseMappingBase
   */
  template <class Derived>
  class FiniteElementSpaceMappingBase
  {
    public:
      /**
       * @brief Evaluates the mapped function on the reference coordinates.
       *
       * For the given function @f$ v \in V(\tau) @f$, performs the following
       * evaluation:
       * @f[
       *  \psi(v)(r)
       * @f]
       * on the reference coordinates @f$ r \in K @f$.
       *
       * @note CRTP function to be overriden in Derived class.
       */
      inline
      auto operator()(const Math::SpatialVector& r) const
      {
        return static_cast<const Derived&>(*this).operator()(r);
      }
  };

  /**
   * @brief Base class for inverse mappings taking functions defined on 
   * to reference elements.
   *
   * For all @f$ \tau \in \mathcal{T}_h @f$ the inverse mapping
   * @f[
   *  \psi^{-1} : V(K) \rightarrow V(\tau)
   * @f]
   * takes functions defined on the reference Banach space @f$ V(K) @f$ to the
   * physical Banach space @f$ V(K) @f$. Here @f$ \tau = x(K) @f$ is the
   * physical element, @f$ K @f$ is the reference element, and @f$ x : K
   * \rightarrow \tau @f$ is the
   * polytope transformation.
   *
   * @see FiniteElementSpaceMappingBase
   */
  template <class Derived>
  class FiniteElementSpaceInverseMappingBase
  {
    public:
      /**
       * @brief Evaluates the mapped function on the physical coordinates.
       *
       * For the given function @f$ v \in V(K) @f$, performs the following
       * evaluation:
       * @f[
       *  \psi^{-1}(v)(p)
       * @f]
       * on the physical coordinates @f$ p \in \tau @f$.
       *
       * @note CRTP function to be overriden in Derived class.
       */
      inline
      auto operator()(const Geometry::Point& pc) const
      {
        return static_cast<const Derived&>(*this).operator()(pc);
      }
  };
}

#endif
