/*
 *          Copyright Carlos BRITO PACHECO 2021 - 2022.
 * Distributed under the Boost Software License, Version 1.0.
 *       (See accompanying file LICENSE or copy at
 *          https://www.boost.org/LICENSE_1_0.txt)
 */
#ifndef RODIN_VARIATIONAL_FINITEELEMENTSPACE_H
#define RODIN_VARIATIONAL_FINITEELEMENTSPACE_H

#include <variant>

#include "Rodin/Types.h"
#include "Rodin/Utility.h"
#include "Rodin/Geometry/Mesh.h"

#include "ForwardDecls.h"
#include "FiniteElement.h"

namespace Rodin::Variational
{
  /**
   * @brief Abstract base class for finite element spaces.
   */
  class FiniteElementSpaceBase
  {
    public:
      FiniteElementSpaceBase() = default;

      FiniteElementSpaceBase(const FiniteElementSpaceBase&) = default;

      FiniteElementSpaceBase(FiniteElementSpaceBase&&) = default;

      FiniteElementSpaceBase& operator=(FiniteElementSpaceBase&&) = default;

      /**
       * @brief Gets the total number of degrees of freedom.
       * @returns Size of the finite element space
       */
      virtual size_t getSize() const = 0;

      /**
       * @brief Gets the dimension of the range space, i.e. the number of
       * components of each basis function.
       * @returns Vector dimension of the finite element space.
       */
      virtual size_t getVectorDimension() const = 0;

      /**
       * @brief Gets the constant reference to the mesh upon which the finite
       * element space is built on.
       * @returns Constant reference to mesh
       */
      virtual const Geometry::MeshBase& getMesh() const = 0;

      /**
       * @brief Gets a set of global degree of freedom indices associated to
       * the polytope of dimension @f$ d @f$ and index @f$ i @f$.
       * @returns Set of indices associated to the @f$ (d, i) @f$-polytope.
       */
      virtual const IndexSet& getDOFs(size_t d, Index i) const = 0;

      /**
       * @brief Gets the global index for the local degree of freedom on the
       * polytope.
       */
      virtual Index getGlobalIndex(const std::pair<size_t, Index>& idx, Index local) const = 0;
  };

  /**
   * @brief Represernts a finite element space.
   */
  template <class Derived>
  class FiniteElementSpace : public FiniteElementSpaceBase
  {
    public:
      /// Parent class
      using Parent = FiniteElementSpaceBase;

      /**
       * @brief Returns the mapping of the function from the physical element
       * to the reference element.
       * @tparam T Callable type
       * @param[in] p Index of the element in the mesh
       * @param[in] v Function defined on an element of the mesh
       *
       * For all @f$ \tau \in \mathcal{T}_h @f$ in the mesh, the finite
       * element space is generated by the bijective mapping:
       * @f[
       *  \psi_\tau : V(\tau) \rightarrow V(R)
       * @f]
       * taking a function @f$ v \in V(\tau) @f$ from the element in the mesh
       * to the reference element @f$ R @f$. Here the notation @f$ V(S) @f$
       * represents a Banach space of functions on the set @f$ S @f$.
       *
       * The callable type T must be a function on the mesh, i.e. the call
       * operator must have the following signature:
       *
       * @code{cpp}
       *  auto operator()(const Geometry::Point&);
       * @endcode
       *
       */
      template <class T>
      auto getMapping(const std::pair<size_t, Index>& p, const T& v) const
      {
        return static_cast<const Derived&>(*this).getMapping(p, v);
      }
  };

  inline
  constexpr
  bool operator==(const FiniteElementSpaceBase& lhs, const FiniteElementSpaceBase& rhs)
  {
    return &lhs == &rhs;
  }
}

#endif
